{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#a-few-notes-on-material-for-mkdocs","title":"A few notes on Material for MkDocs","text":"<p>From mkdocs.org,</p> <p>Material for MkDocs is a powerful documentation framework on top of MkDocs, a static site generator for project documentation.</p> <p>This framework is similar to documentation platforms used by Virginia Tech ARC and the Virginia Tech Cyber Range (albeit with a custom homepage). It is also similar to Bookdown, but unlike Bookdown, MkDocs does not support intrinsic/dynamic R code (etc.).</p> <p>There is a mock-up article under the Molecular Dynamics tab that uses some of the features we might be interested in.</p>"},{"location":"#other-stuff","title":"Other stuff","text":"<ul> <li>Can be hosted and published on GitHub/GitHub Pages (which is where this mock-up is now!)<ul> <li>Page deployment can also be automated.</li> </ul> </li> <li>Very customizable, lots of extensions, uses markdown.</li> <li>Can view changes live via <code>mkdocs serve</code>.</li> </ul>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    assets/   # Images and other media embedded in articles.\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"default/","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"default/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"default/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"Molecular%20Dynamics/GROMACS/PCA/","title":"Principal Component Analysis (PCA)","text":""},{"location":"Molecular%20Dynamics/GROMACS/PCA/#introduction","title":"Introduction","text":"<p>Principal component analysis (PCA) allows us to identify major changes in conformation and movement after MD simulation.</p> <p>This guide assumes you have all files in the same directory. If not, be sure to reference each file from their respective directories \u2013 though it will be much easier later if all files are in the same directory.</p> <p>Small systems will be able to do the initial set-up, <code>gmx covar</code>, and <code>gmx anaeig</code> within the same interactive session. If you have very large/complex systems you wish to compare, you may need to submit a slurm job to run these commands.</p> <p>Interactive sessions allow us to use an allocation of ARC to actively submit commands, rather than queueing a job and waiting.</p> <p>To begin an interactive session of 2 hours:</p> <pre><code>interact -p v100_dev_q -A bevanlab --gres=gpu:1 --nodes=1 --ntasks-per-node=12 -t 2:00:00\n</code></pre> <p>Then import the necessary modules (copy and paste individual lines to the command line):</p> <pre><code>module load apps site/infer/easybuild/setup\nmodule load CMake/3.15.3-GCCcore-8.3.0\nmodule load CUDA/10.1.243-GCC-8.3.0\n\nexport MODULEPATH=$MODULEPATH:/projects/bevanlab/software/infer/modules/modules/infer-skylake/all\nmodule load gromacs-v100/2020.4\n</code></pre>"},{"location":"Molecular%20Dynamics/GROMACS/PCA/#initial-set-up","title":"Initial set-up","text":"<p>You should have the following files from your MD simulations:</p> <ul> <li>Final trajectory files (.xtc) for all replicates</li> <li>Topology file (.tpr) from any replicate</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/PCA/#concatenate-trajectory-files","title":"Concatenate trajectory files","text":"<p>All trajectory (.xtc) replicates must be concatenated, or joined together, in order to analyze the average motion of your system.</p> <p>Note</p> <p>You MUST use the <code>-cat</code> option, otherwise duplicate timeframes will be overwritten by the last XTC file used.</p> <pre><code>gmx trjcat -f rep1.xtc rep2.xtc rep3.xtc -cat -o all_cat.xtc\n</code></pre>"},{"location":"Molecular%20Dynamics/GROMACS/PCA/#get-backbone-only-trajectory-xtc","title":"Get backbone-only trajectory (.xtc)","text":"<p>Since covariance analysis is performed on the protein backbone, you will need to generate an xtc trajectory file containing the protein backbone only.</p> <p>To generate a backbone-only XTC file:</p> <p>To generate a backbone-only XTC file: <pre><code>gmx trjconv -s topology.tpr -f all_cat.xtc -o all_cat_backbone.xtc\n</code></pre></p> <p>Select backbone when prompted.</p>"},{"location":"Molecular%20Dynamics/GROMACS/PCA/#get-backbone-only-topology-file-tpr","title":"Get backbone-only topology file (.tpr)","text":"<p>The topology (.tpr) and trajectory (.xtc) files MUST match in atom count, otherwise you will get a fatal error when trying to run <code>gmx covar</code>.</p> <p>To guarantee a match, create a backbone-only TPR file: <pre><code>gmx convert-tpr -s topology.tpr -o backbone.tpr\n</code></pre></p> <p>Select backbone when prompted. It does not matter which TPR file is used (whether replicate 1 or 3), as <code>gmx covar</code> will only be referencing the structural information.</p>"},{"location":"Molecular%20Dynamics/GROMACS/PCA/#covariance-analysis","title":"Covariance analysis","text":"<p>You need the new concatenated backbone-only XTC and TPR files generated in the initial set-up to perform covariance analysis. Because this step generates many files, it is advisable to make a new directory (e.g., <code>covar/</code>) to store your outputs.</p> <p>To perform covariance analysis:</p> <pre><code>gmx covar -f all_cat_backbone.xtc -s backbone.tpr -o ./covar/eigenval.xvg -ascii ./covar/ascii.dat -av ./covar/ave.pdb -v ./covar/eigenvec.trr\n</code></pre> <p>Select backbone when prompted.</p> <p>This produces the following outputs:</p> <ul> <li><code>-o</code>: eigenvalues of the covariance matrix</li> <li><code>-ascii</code>: the whole covariance matrix, in text form</li> <li><code>-av</code>: the average structure</li> <li><code>-v</code>: the full precision trajectory</li> </ul> <p>Repeat this for all systems. Be sure to use a clear naming convention, as this data will be projected onto each other in the next step.</p>"},{"location":"Molecular%20Dynamics/GROMACS/PCA/#analysis-of-eigenvectors","title":"Analysis of eigenvectors","text":"<p>In order to analyze changes in motion during simulation, the outputs from the previous step must be processed using <code>gmx anaeig</code>.</p> <p>The following files are needed for every system you plan to compare:</p> <ul> <li><code>backbone.xtc</code></li> <li><code>eigenval.xvg</code></li> <li><code>ave.pdb</code></li> <li><code>eigenvect.trr</code></li> </ul> <p>To perform eigenvector analysis:</p> <pre><code># Project MUT onto WT\ngmx anaeig -s wt_ave.pdb -f mut_backbone.xtc -v wt_eigenvec.trr -eig wt_eigenval.xvg -proj mut_wt_proj-ev.xvg -extr mut_wt_ev.pdb -2d mut_wt_eigtraj.xvg \n\n# Project WT onto MUT\ngmx anaeig -s mut_ave.pdb -f wt_backbone.xtc -v mut_eigenvec.trr -eig mut_eigenval.xvg -proj wt_mut_proj-ev.xvg -extr wt_mut_ev.pdb -2d wt_mut_eigtraj.xvg\n</code></pre> <p>Select backbone, protein, or system when prompted (these are all the same).</p> <p>This produces the following outputs:</p> <ul> <li><code>-proj</code>: the projections of trajectories on the first and last eigenvectors</li> <li><code>-extr</code>: the two extreme projections along the average structure</li> <li><code>-2d</code>: 2D projection of trajectories on the eigenvectors</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/PCA/#data-visualization-and-analysis","title":"Data visualization and analysis","text":""},{"location":"Molecular%20Dynamics/GROMACS/PCA/#graphing-2d-projections","title":"Graphing 2D projections","text":"<p>You will need the <code>mdpca.py</code> file to create PCA graphs from the 2D projection data. A version of this file is available (somewhere). You will also need a way to run Python 3 scripts.</p> <p>The following files are needed for every system you plan to compare:</p> <ul> <li><code>eigtraj.xvg</code></li> </ul> <p>All relevant files must be in the same directory as the script OR use a path to the file.</p>"},{"location":"Molecular%20Dynamics/GROMACS/PCA/#using-mdpcapy","title":"Using <code>mdpca.py</code>","text":"<p>Open the script in a code editor and configure the following:</p> <ol> <li>Under <code>#2D INPUT FILES</code>, change file names to match the two <code>eigtraj.xvg</code> files.</li> <li>Under <code>#GRAPH COLORS</code>, change the hex codes to adjust graph colors.</li> <li>Under <code>#TITLE AND FILE PARAMETERS</code>, change the graph title and output file name.<ul> <li>The graph title can be styled using Mathtext or LaTeX.</li> <li>By default, graphs are saved as PNG files.</li> </ul> </li> </ol> <p>Save and run the script. The output will be two side-by-side projection graphs with a single title:</p> <p></p> <p>The degree of overlap between the two datasets represents how structurally similar the systems are during simulation. Overlap in the data suggests these simulations take on more similar structures, or sample similar conformational space. Conversely, regions without overlap indicate differences in conformation.</p>"},{"location":"Molecular%20Dynamics/GROMACS/PCA/#visualizing-extreme-structures-with-pymol","title":"Visualizing extreme structures with PyMOL","text":"<p>The conformational changes indicated by the 2D graphs can be visualized by looking at the extreme structures that were generated by <code>-extr</code> of <code>gmx anaeig</code>. Opening one of these PDB files in PyMOL gives us a protein structure with two frames. Each frame represents the first and last eigenvectors, which are depicted in the 2D graph as the X- and Y-axes, respectively.</p> <p>If your 2D graphs show any regions without overlap, these two frames should be different when you toggle between them. We can add arrow indicators to show the degree and direction of these differences using <code>modevectors</code>.</p> <p>To do this, you will need the <code>modevectors.py</code> script. You can additionally use the optional <code>modesplit.py</code> script, which automates part of this process with a little extra set-up. Place all scripts in the same directory as the PDB files you are working with.</p>"},{"location":"Molecular%20Dynamics/GROMACS/PCA/#using-modevectorspy","title":"Using <code>modevectors.py</code>","text":"<p>The <code>modevectors.py</code> script requires that the two frames be split into two PyMOL objects. This can be done through the graphical user interface (GUI) or the PyMOL command line.</p> GUICommand line <p>To do this in the PyMOL GUI, find the object buttons at the right of the program. Navigate to either your protein or the \"all\" object and click the A icon.</p> <p>Navigate to the \"state\" option, then select \"split\".  </p> <p>This will create 2 new objects, \"protein_0001\" and \"protein_0002\", which correspond to the two frames.</p> <p>To do this in the PyMOL command line, type <code>split_states all</code>.   This will create 2 new objects, \"protein_0001\" and \"protein_0002\", which correspond to the two frames.</p> <p>You can now use <code>modevectors.py</code>! Run each of the following lines individually in the PyMOL command line, replacing the object names as appropriate:</p> <pre><code>run modevectors.py\n\nmodevectors first_obj_frame, last_obj_frame, skip=0\n</code></pre> <p><code>skip</code> indicates how many vectors (arrows) are skipped during rendering. Adjust this if the final render is too visually cluttered.</p>"},{"location":"Molecular%20Dynamics/GROMACS/PCA/#using-modesplitpy","title":"Using <code>modesplit.py</code>","text":"<p>Repeatedly running Modevectors can be tedious if you are analyzing multiple systems with the same protein, or multi-subunit systems where you want to analyze each subunit individually. The <code>modesplit.py</code> script is an additional (optional) script that can split subunits and automate the above process. It requires some set-up, but afterwards the script can be run as-is for all relevant PDB files.</p> <p>Open <code>modesplit.py</code> in a code editor. Define all protein subunits in the <code>#CHAINS</code> dictionary. The dictionary can be modified for any number of subunits, but at least one entry is required to run.</p> <p>Note that the <code>start_index</code> and <code>end_index</code> ask for the index of the first and last atoms of the subunit, not residues. This is to avoid duplicates with homo-oligomers, which will have the same residue numbers designated across identical subunits.</p> <p>To find the index of an atom in PyMOL:</p> <ol> <li>Select the first residue of the subunit. In the command line, type <code>index %sele</code> and hit enter. PyMOL will return three lines of text. Note the number at the end of the first line of the output.</li> <li>Click off the protein to deselect the residue.</li> <li>Repeat step 1, instead selecting the last residue of the subunit. Note the number at the end of the last line of the output.</li> <li>Repeat for all subunits.</li> </ol> Output of the index command. <p>Update the indices, then save the file. Load it into PyMOL using <code>run modesplit.py</code> in the command line.</p> <p>Note</p> <p>This script will also automatically run <code>modevectors.py</code>. You can adjust the parameters for Modevectors in line 47.</p>"},{"location":"Molecular%20Dynamics/GROMACS/PCA/#analyzing-motion-with-direct-id","title":"Analyzing motion with DIRECT-ID","text":"<p>DIRECT-ID is a program that identifies residues with the greatest variance in movement between two systems based on the covariance matrices produced by <code>gmx covar</code>.</p> <p>The following files are needed to perform DIRECT-ID analysis:</p> <ul> <li><code>ascii.dat</code> for both systems of interest</li> <li><code>ave.pdb</code> for either system</li> </ul> <p>DIRECT-ID should already be set-up on ARC and can be accessed using the following command:</p> <pre><code>direct_id 3NXN wt_ascii.dat mut_ascii.dat wt_ave.pdb direct_id_output.txt\n</code></pre> <p>Depending on where you are trying to run the analysis, you may need to run the command using a path to the DIRECT-ID program.</p> <pre><code>(../)../../direct_id 3NXN wt_ascii.dat mut_ascii.dat wt_ave.pdb direct_id_output.txt\n</code></pre> <p>Regardless of how the program is run, two outputs will be generated: a text file containing a list of atoms with the most variance in movement, and a command line output listing the residues.</p> <p>In most cases, the terminal output is the most relevant. Record or screenshot this output, as it does not get saved in a file. The residues listed should match those with the greatest motion in the Modevectors analysis.</p>"},{"location":"Molecular%20Dynamics/GROMACS/PCA/#additional-resources","title":"Additional Resources","text":"<ul> <li>gmx trjcat</li> <li>gmx trjconv</li> <li>gmx convert-tpr</li> <li>gmx covar</li> <li>gmx anaeig</li> <li>Modevectors</li> <li>DIRECT-ID</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/RMS/","title":"Root Mean Square Deviation and Fluctuation (RMSD/RMSF)","text":""},{"location":"Molecular%20Dynamics/GROMACS/RMS/#introduction","title":"Introduction","text":"<p>Root-mean-square deviation (RMSD) is a measure of how much a structure differs from a starting or reference structure, usually reported in angstroms (\u00c5) or nanometers (nm). Plotting RMSD against time tells us two things:</p> <ol> <li>How much the protein structure has changed since the start of the simulation. Greater RMSD values indicate greater change, and vice versa.</li> <li>Whether our simulation has achieved convergence, or a state of equilibrium.</li> </ol> RMSD graph from one set of simulations. RMSD is plotted as nanometer (nm) versus time (ns). <p>Similarly, root-mean-square fluctuation (RMSF) allows us to identify regions that are highly flexible throughout the simulation. RMSF is plotted as a function of protein residue.</p> RMSF graph from the same simulations. RMSF is plotted as nanometer (nm) versus residue number. <p>You should have the following files for RMSD/RMSF:</p> <ul> <li>Trajectory files (.xtc)</li> <li>Topology file (.tpr)</li> <li>Index files (.ndx) - OPTIONAL</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/RMS/#rmsd-and-rmsf-analysis-in-gromacs","title":"RMSD and RMSF analysis in GROMACS","text":"<p>To perform RMSD analysis, use <code>gmx rms</code>:</p> <pre><code>gmx rms -f trajectory.xtc -s topology.tpr -o rmsd.xvg\n</code></pre> <p>You will be prompted to select two groups, one for least squares fit and one for the RMSD calculations. Select <code>Backbone</code> for both of these.</p> <p>Some additional options that you may find useful:</p> <ul> <li><code>-n</code>: index file to be used (see Creating Index Files)</li> <li><code>-tu</code>: specifies time units (default is ps)</li> <li><code>-b</code> and <code>-e</code>: specifies the frames to begin and end</li> <li><code>skip</code>: number of frames to skip, useful for large simulations</li> </ul> <p>To perform RMSF analysis, use <code>gmx rmsf</code>:</p> <pre><code>gmx rmsf -f trajectory.xtc -s topology.tpr -o rmsf.xvg -res\n</code></pre> <p>Select <code>Backbone</code> when prompted. The <code>-res</code> option is required to calculate the average fluctuation for each residue.</p> <p>Some additional options that you may find useful:</p> <ul> <li><code>-n</code>: index file to be used (see Creating Index Files)</li> <li><code>-b</code> and <code>-e</code>: specifies the frames to begin and end</li> <li><code>skip</code>: number of frames to skip, useful for large simulations</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/RMS/#additional-resources","title":"Additional Resources","text":"<ul> <li>gmx rms</li> <li>gmx rmsf</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/misc/","title":"Miscellaneous","text":"<p>Annotations (1) differ from footnotes<sup>1</sup> and can be used to add lil notes.</p> <ol> <li> <p>This is an annotation! (1)</p> <ol> <li>This is also an annotation \ud83d\ude32</li> </ol> </li> </ol> <p>The documentation also has some other cool useful things.</p>"},{"location":"Molecular%20Dynamics/GROMACS/misc/#examples-of-code","title":"Examples of Code","text":""},{"location":"Molecular%20Dynamics/GROMACS/misc/#code-blocks-with-syntax-highlighting","title":"Code blocks with syntax highlighting","text":"bash<pre><code>module load apps site/infer/easybuild/setup\nmodule load CMake/3.15.3-GCCcore-8.3.0\nmodule load CUDA/10.1.243-GCC-8.3.0\n\nexport MODULEPATH=$MODULEPATH:/projects/bevanlab/software/infer/modules/modules/infer-skylake/all\nmodule load gromacs-v100/2020.4\n</code></pre> python<pre><code>import matplotlib.pyplot as plt\nimport pandas as pd\nfrom shapely import geometry, ops\n\ndef gather_data():\n    ...\n\nif __name__ == '__main__':\n    gather_data()\n</code></pre> <ol> <li> <p>This is a footnote!\u00a0\u21a9</p> </li> </ol>"}]}